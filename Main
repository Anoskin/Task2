#include <coroutine>
#include <memory>
#include <iostream>
#include <fstream>

template <typename T>
struct Stream {
    struct promise_type;
    using handle_type = std::coroutine_handle<promise_type>;
    Stream(handle_type h) : coro(h) {}                       
    handle_type coro;
    std::shared_ptr<T> value;
    ~Stream() {
        if (coro) {
            coro.destroy();
        }
    }
    Stream(Stream &&other) : coro(other.coro) {
        other.coro = nullptr;
    }
    Stream& operator=(Stream &&other) {
        coro = other.coro;
        other.coro = nullptr;
        return *this;
    }
    T getValue() {
        return coro.promise().current_value;
    }
    bool next() {                                               
        coro.resume();
        return not coro.done();
    }
    struct promise_type {
        promise_type() = default;                               
        ~promise_type() = default;
        auto initial_suspend() {                                
            return std::suspend_always{};
        }
        T current_value;
    };
};
Stream <int> getNext(int n = 1, int step = 1) {
    auto value = 2 * n + 3 * n + 5;
    for (int i = 0; ; ++i) {
        co_yield value;
        value += step;
    }
}
int main() {
    std::fstream fout;
    std::fstream fout2;
    fout.open("stream1.txt");
    fout2.open("stream2.txt");
    std::cout << "getNext():";
    auto gen = getNext();
    for (int i = 0; i <= 10000; ++i) {
        gen.next();
        fout1 << gen.getValue() <<" ";                    
    }
    std::cout << "\ngetNext(100, -10):";
    auto gen2 = getNext(100, -10);
    for (int i = 0; i <= 10000; ++i) {
        gen2.next();
         fout2 << gen.getValue() <<" "; 
    }
    fout1.close();
    fout2.close();
}
